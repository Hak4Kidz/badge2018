/*******************************************************************************
 * @file callback.c
 * @brief USB Callbacks.
 *******************************************************************************/

//=============================================================================
// src/callback.c: generated by Hardware Configurator
//
// This file is only generated if it does not exist. Modifications in this file
// will persist even if Configurator generates code. To refresh this file,
// you must first delete it and then regenerate code.
//=============================================================================
//-----------------------------------------------------------------------------
// Includes
//-----------------------------------------------------------------------------
#include <SI_EFM8UB1_Register_Enums.h>
#include <efm8_usb.h>
#include "descriptors.h"
#include "board.h"

//-----------------------------------------------------------------------------
// Constants
//-----------------------------------------------------------------------------

#define CDC_CONTROL_INTERFACE_INDEX 0
#define HID_INTERFACE_INDEX 2

//-----------------------------------------------------------------------------
// Variables
//-----------------------------------------------------------------------------

uint8_t tmpBuffer[8];
uint8_t uartAwaitingFirstChar = 1;

//-----------------------------------------------------------------------------
// Functions
//-----------------------------------------------------------------------------

void USBD_SofCb(uint16_t sofNr) {

}

void USBD_DeviceStateChangeCb(USBD_State_TypeDef oldState,
		USBD_State_TypeDef newState) {
	IE_EA = 0;
	if (newState == USBD_STATE_ADDRESSED) {
		// If we've been addressed then we aren't connected
		//  to a dedicated charging port anymore
		powerFlags &= ~POWER_FLAG_USB_DCP_CONNECTED;
		powerFlags |= POWER_FLAG_USB_HOST_CONNECTED | POWER_FLAG_POWER_FLAGS_CHANGED;
	} else if (newState == USBD_STATE_CONFIGURED) {
		powerFlags |= POWER_FLAG_USB_HOST_CONFIGURED | POWER_FLAG_POWER_FLAGS_CHANGED;
	} else if (newState == USBD_STATE_SUSPENDED) {
		if (powerFlags & POWER_FLAG_USB_HOST_CONFIGURED) {
			powerFlags &= ~POWER_FLAG_USB_CDP_CONNECTED;
		}
		powerFlags &= ~(POWER_FLAG_VIRTUAL_SWITCH_ON |
				POWER_FLAG_USB_HOST_CONNECTED | POWER_FLAG_USB_HOST_CONFIGURED);
		powerFlags |= POWER_FLAG_POWER_FLAGS_CHANGED;
	}
	IE_EA = 1;
}

USB_Status_TypeDef USBD_SetupCmdCb(
		SI_VARIABLE_SEGMENT_POINTER(setup, USB_Setup_TypeDef, MEM_MODEL_SEG)) {
	USB_Status_TypeDef retVal = USB_STATUS_REQ_UNHANDLED;

	if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
			&& (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
			&& (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)) {
		// A HID device must extend the standard GET_DESCRIPTOR command
		// with support for HID descriptors.

		switch (setup->bRequest) {
		case GET_DESCRIPTOR:
			if ((setup->wValue >> 8) == USB_HID_REPORT_DESCRIPTOR) {
				switch (setup->wIndex) {
				case 2: // Interface 2
					USBD_Write(EP0, ReportDescriptor2,
							   EFM8_MIN(sizeof(ReportDescriptor2), setup->wLength),
							   false);
					retVal = USB_STATUS_OK;
					break;
				}
			} else if ((setup->wValue >> 8) == USB_HID_DESCRIPTOR) {
				switch (setup->wIndex) {
				case 2: // Interface 2
					USBD_Write(EP0, (&configDesc[84]),
							EFM8_MIN(USB_HID_DESCSIZE, setup->wLength), false);
					retVal = USB_STATUS_OK;
					break;
				}
			}
			break;
		}
	} else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_STANDARD)
			&& (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
			&& (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_DEVICE)
			&& (setup->bRequest == GET_DESCRIPTOR)
			&& ((setup->wValue >> 8) == BOS_DESCRIPTOR_TYPE)) {
				USBD_Write(EP0, bosDesc, EFM8_MIN(sizeof(bosDesc), setup->wLength), false);
				retVal = USB_STATUS_OK;
	} else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_VENDOR)
			&& (setup->bmRequestType.Direction == USB_SETUP_DIR_IN)
			&& (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_DEVICE)
			&& (setup->bRequest == 0xc7)
			&& (setup->wIndex == 2)
			&& (setup->wValue == 4)) {
				USBD_Write(EP0, urlDesc, EFM8_MIN(sizeof(urlDesc), setup->wLength), false);
				retVal = USB_STATUS_OK;
	} else if ((setup->bmRequestType.Type == USB_SETUP_TYPE_CLASS)
	           && (setup->bmRequestType.Recipient == USB_SETUP_RECIPIENT_INTERFACE)) {
		switch (setup->wIndex) {
		case CDC_CONTROL_INTERFACE_INDEX:
			switch (setup->bRequest)
			{
			case 0x20: // SET_LINE_CODING
				if (setup->bmRequestType.Direction == USB_SETUP_DIR_OUT && setup->wLength == 7)
				{
					USBD_Read(EP0, tmpBuffer, 7, true);
					retVal = USB_STATUS_OK;
				} else {
					retVal = USB_STATUS_REQ_ERR;
				}
				break;
			case 0x21: // GET_LINE_CODING
				if (setup->bmRequestType.Direction == USB_SETUP_DIR_IN && setup->wLength == 7)
				{
					tmpBuffer[0] = uartBPS & 0xff;
					tmpBuffer[1] = (uartBPS >> 8) & 0xff;
					tmpBuffer[2] = (uartBPS >> 16) & 0xff;
					tmpBuffer[3] = (uartBPS >> 24) & 0xff;
					tmpBuffer[4] = uartStopBits;
					tmpBuffer[5] = uartParityType;
					tmpBuffer[6] = uartDataBits;
					USBD_Write(EP0, tmpBuffer, 7, false);
					retVal = USB_STATUS_OK;
				} else {
					retVal = USB_STATUS_REQ_ERR;
				}
				break;
			case 0x22: // SET_CONTROL_LINE_STATE
				if (setup->bmRequestType.Direction == USB_SETUP_DIR_OUT)
				{
					// In an ideal world, we could rely on DTR and/or RTS to
					// control whether the UART is active. But we don't live
					// in that world.
					uartFlags = (setup->wValue & 3) | UART_FLAGS_UPDATED;
					retVal = USB_STATUS_OK;
				} else {
					retVal = USB_STATUS_REQ_ERR;
				}
				break;
			}
			break;
		case HID_INTERFACE_INDEX:
			// Implement the necessary HID class specific commands.
			switch (setup->bRequest)
			{
			case USB_HID_SET_IDLE:
				if (((setup->wValue & 0xFF) == 0)             // Report ID
						&& (setup->wLength == 0)
						&& (setup->bmRequestType.Direction != USB_SETUP_DIR_IN))
				{
					retVal = USB_STATUS_OK;
				}
				break;

			case USB_HID_GET_IDLE:
				if ((setup->wValue == 0)                      // Report ID
						&& (setup->wLength == 1)
						&& (setup->bmRequestType.Direction == USB_SETUP_DIR_IN))
				{
					tmpBuffer[0] = 24;
					USBD_Write(EP0, tmpBuffer, 1, false);
					retVal = USB_STATUS_OK;
				}
				break;
			}
			break;
		}
	}

	return retVal;
}

uint16_t USBD_XferCompleteCb(uint8_t epAddr, USB_Status_TypeDef status,
		uint16_t xferred, uint16_t remaining) {
	uint32_t newBaudRate;

	switch (epAddr) {
	case EP0:
		newBaudRate = tmpBuffer[0];
		newBaudRate |= (uint32_t)tmpBuffer[1] << 8;
		newBaudRate |= (uint32_t)tmpBuffer[2] << 16;
		newBaudRate |= (uint32_t)tmpBuffer[3] << 24;
		// We can't go lower than 93750 bps without changing the TIMER1
		// prescaler. In practice you'll never want to go lower than 115200
		// (the default baud rate of the ESP32 console), so we ignore any
		// requests to go lower and don't bother changing the prescaler.
		if (newBaudRate >= 115200) {
			uartBPS = newBaudRate;
			TH1 = ((0x100 - ((48000000 / uartBPS) >> 1)) << TH1_TH1__SHIFT);
		}
		// TODO: Actually change the UART here, but these should always be 8N1
		uartStopBits = tmpBuffer[4];
		uartParityType = tmpBuffer[5];
		uartDataBits = tmpBuffer[6];
		break;
	case EP2OUT:
		if (uartAwaitingFirstChar) {
			if (*txBuf == '!') {
				USBD_Stop();
				reboot_into_bootloader();
			} else {
				uartAwaitingFirstChar = 0;
			}
		}
		if (fifo_getLength(&txFifo) == 0 && xferred) {
			SBUF0 = *txBuf;
			fifo_putData(&txFifo, txBuf + 1, xferred - 1);
		} else {
			fifo_putData(&txFifo, txBuf, xferred);
		}
		lastUARTTxTime = _cur_ms;
		break;
	case EP3IN:
		// FIXME: This could be either report
		break;
	}
	return 0;
}

